Эта статья является продолжением серии статей по производительности в .NET. Первая статья лежит <a href="http://habrahabr.ru/post/229741/">здесь</a>.

В свете того, что к прошлой статье сразу пошли комментарии в духе: "Сильно ли вырастит производительность в моём проекте?" и "Стоит ли срочно изменять все подобные куски кода?", сразу хочется пояснить смысл этих статей. Я описываю некоторые приёмы и особенности платформы, которые можно легко применять почти не влияя на конечную функциональность проекта, но при этом немного (или много, в зависимости от контекста) улучшить производительность. Так что смысл от этих приёмов есть когда:

<ul>
	<li>Вы  пишете новый код и вы хотите написать его чуть лучше</li>
	<li>Вы просматриваете участки кода, которые выполняются очень часто. В этих случаях может быть влияние даже таких мелочей</li>
	<li>Когда вы используете чужой код. В комментариях к прошлой статье посоветовали замечательное расширение <a href="http://blog.jetbrains.com/dotnet/2014/06/06/heap-allocations-viewer-plugin/">Heap Allocations Viewer</a>. Оно конечно хорошо помогает, но например оно не покажет вам, что если использовать перечисление в качестве ключа для словаря, то будет происходить boxing. Так что всякие инструменты хорошо, но программист должен осознавать, что происходит в его коде, если он хочет выжать максимум из него</li>
</ul>
Так что я не призываю вас бежать и исправлять весь код в ваших проектах. Более того, я призываю вас этого не делать, потому что, как я уже написал, эти приёмы можно применить легко и бездумно, а когда на автомате меняется большое количество кода, то очень легко внести туда новых ошибок.

Хорошо, надеюсь я прояснил цель моих статей и мы можем приступать.
<habracut />
<h4>1. Сравнение строк</h4>
Многие наверное знают что такое <a href="http://msdn.microsoft.com/en-us/library/system.stringcomparison(v=vs.110).aspx">StringComparison.Ordinal</a>. Для тех кто забыл напомню. Если вы указываете такое сравнение в методах сравнения строк, то сравнение происходит без использования культур. Подробные примеры есть по ссылке. Это работает гораздо быстрей, чем с использованием культур, потому что используются лишь коды символов, которые есть в строках без дополнительных обработок. Мы уже давно используем такое сравнение во всех местах, где это возможно. Вы скажете "ну и что тут такого, мы тоже делаем также", но это еще не всё.

Давайте установим небольшое расширение для Visual Studio: <a href="http://visualstudiogallery.msdn.microsoft.com/24b56e51-fcc2-423f-b811-f16f3fa3af7a">Concurrency Visualizer</a>. С его помощью можно видеть работу потоков и то, в какие моменты происходит синхронизация.

Напишем небольшой тест, который будет сравнивать строки используя культуру:
<source lang="cs">
const Int32 length = 10000;
var tasks = new Task[length];
var strings = Enumerable.Range(0, length).Select(i => Guid.NewGuid().ToString()).ToArray();

for (var i = 0; i < length; ++i)
{
	tasks[i] = Task.Run(() =>
		{
			for (var j = 0; j < length; ++j)
			{
				if (j != (length - j - 1) && String.Compare(strings[j], strings[length - j - 1], StringComparison.CurrentCulture) == 0)
					break;
			}
		});
}

Task.WaitAll(tasks);
</source>
Теперь посмотрим, что будет если запустить проект под Concurrency Visualizer и оставить для рассмотрения только потоки, которые занимались работой:
<img src="//habrastorage.org/files/eba/2c6/cfc/eba2c6cfc0fc4b31b481d6b0ff2a92ac.png"/>

Если нажать Demistify на красные блоки, то увидим, что это <a href="http://msdn.microsoft.com/query/dev12.query?appId=Dev12IDEF1&l=EN-US&k=k(vs.cv.threads.timeline.synchronization)%3bk(TargetFrameworkMoniker-.NETFramework%2cVersion%3dv4.5)&rd=true">синхронизация</a> вызванная обращением к одному из примитивов синхронизации ядра.

Теперь сделаем небольшое изменение, поменяем StringComparison.CurrentCulture на StringComparison.Ordinal и запустим заново:
<img src="//habrastorage.org/files/a33/c37/926/a33c37926d48497599dc2c48dadf7fe2.png"/>

Мы видим, что синхронизации нет, только работа и переключение контекста. Картина для обоих случаев, конечно, меняется от запуска к запуску, но основная мысль в не в том, что Ordinal сравнение работает быстрей (на моей машине этот тест с Ordinal выполнялся в среднем в 10 раз быстрей чем с CurrentCulture), а в том, что при сравнение с помощью культур возникает еще и синхронизация между потоками.

А теперь главное, как мы наткнулись на это в своём коде. Хоть мы и сравнивали все строки в коде с помощью Ordinal, но мы забыли, что сроки еще и сравниваются внутри различных реализаций IDictionary с ключом строкой. Под большой нагрузкой этой проявляется и мы получили такой stack trace:
<source lang="cs">
Wait Time
2 of 1757: 2.8% (1.328s of 46.718s)

clr.dll!func@0x180008eb0+0x3a - [Unknown]:[Unknown]
clr.dll!func@0x180008e80+0x1e - [Unknown]:[Unknown]
clr.dll!func@0x180008d98+0x77 - [Unknown]:[Unknown]
clr.dll!func@0x180136390+0x2d - [Unknown]:[Unknown]
clr.dll!func@0x180131540+0x132 - [Unknown]:[Unknown]
clr.dll!func@0x18013520c+0x4c - [Unknown]:[Unknown]
mscorlib.ni.dll!func@0x644785619f0+0x170 - [Unknown]:[Unknown]
mscorlib.dll!System::Globalization::CompareInfo::Compare+0x9e - [Unknown]:[Unknown]
</source>
Не смотрите на такой маленький процент от этого случая. Если вы посмотрите на Concurrency Visualizer, то увидите много потоков, например, спящих всё время жизни. Их создает ThreadPool и они не используются, но учитываются в общем времени синхронизации. В нашем случае понять откуда там сваливается в лок поток сравнивающий строки сложно без исходников нативной части, а исходники управляемой части заканчиваются <a href="http://referencesource.microsoft.com/#mscorlib/system/globalization/compareinfo.cs">этим</a>. Можно конечно поизучать код моно начиная <a href="https://github.com/mono/mono/blob/master/mcs/class/corlib/System.Globalization/CompareInfo.cs">отсюда</a>, переходя <a href="https://github.com/mono/mono/blob/master/mcs/class/corlib/Mono.Globalization.Unicode/SimpleCollator.cs">сюда</a>, а затем <a href="https://github.com/mono/mono/blob/97bb0ff149e498447c0e98901e4d2268cde7259d/mono/metadata/locales.c">сюда</a>, но в целом это совсем другой код. Либо там стоит где-то лок на доступ к культурам, либо в процессе сравнения выделяются объекты на куче, что в свою очередь тоже может вызвать лок. Но это предположения, если кто-то сможет сказать точно, что происходит, то будем рады услышать.

После того, как мы обнаружили эту проблему, мы стали в конструктора всех реализаций IDictionary с ключом строкой передавать удобный <a href="http://msdn.microsoft.com/en-us/library/system.stringcomparer.ordinal(v=vs.110).aspx">StringComparer.Ordinal</a>, что еще немного улучшило производительность.

<h4>2. Еще немного о boxing: GetEnumerator() в foreach</h4>
Все знают, что foreach использует <a href="http://en.wikipedia.org/wiki/Duck_typing">duck typing</a>. То есть, на самом деле, чтобы использовать объект в качестве цели для foreach, не нужно иметь реализацию <code>IEnumerable</code> или <code>IEnumerable<T></code>. <a href="http://msdn.microsoft.com/en-us/library/9yb8xew9.aspx">Достаточно</a> реализовать GetEnumerator(), MoveNext(), Reset() и Current.

Рассмотрим два простых и похожих метода:
<source lang="cs">
private static void IterateClass<T>(List<T> list)
{
	foreach (var item in list)
		Console.WriteLine(item);
}

private static void IterateInterface<T>(IEnumerable<T> enumerable)
{
	foreach (var item in enumerable)
		Console.WriteLine(item);
}
</source>
Вроде они должны делать одно и то же, но IL код подсказывает нам интересную деталь:
<source lang="cs">
.method private hidebysig static void  IterateClass<T>(class [mscorlib]System.Collections.Generic.List`1<!!T> list) cil managed
{
  .maxstack  1
  .locals init ([0] !!T item,
           [1] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!!T> CS$5$0000)
  IL_0000:  ldarg.0
  IL_0001:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<!!T>::GetEnumerator()
 ...

.method private hidebysig static void  IterateInterface<T>(class [mscorlib]System.Collections.Generic.IList`1<!!T> list) cil managed
{
  .maxstack  1
  .locals init ([0] !!T item,
           [1] class [mscorlib]System.Collections.Generic.IEnumerator`1<!!T> CS$5$0000)
  IL_0000:  ldarg.0
  IL_0001:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<!!T>::GetEnumerator()
...
</source>
Если вы посмотрите внимательно, то увидите, что для второго метода, где передается интерфейс, на стеке выделяется объект reference типа <code>IEnumerator`1<!!T></code>, а для первого метода создается value тип <code>List`1/Enumerator<!!T></code>.

Теперь самое интересное. Если делать enumerator, возвращаемый из GetEnumerator(), классом, то при каждом вызове foreach будет создаваться объект на куче. По этой причине все стандартные коллекции делают explicit реализацию интерфейсов <code>IEnumerable</code> и <code>IEnumerable<T></code>, а публичный метод GetEnumerator() возвращает структуру, например <a href="http://msdn.microsoft.com/en-us/library/b0yss765(v=vs.110).aspx"><code>public List<T>.Enumerator GetEnumerator()</code></a>. Но, если ваш метод принимает в качестве параметра <code>IEnumerable<T></code> (что советует делать Resharper, когда это возможно) для итерации по нему, то при вызове GetEnumerator() будет происходить boxing из-за того, что структура будет приводиться к интерфейсу IEnumerator (либо будет создание нового объекта на куче, если в коллекции не предусмотрен value тип итератор).

По этой причине есть три совета:
<ul>
	<li>Если вы делаете свою коллекцию, то не забывайте делать свою структура enumerator'а, которая будет возвращаться для foreach. Если вы используете какую-то стандартную коллекцию внутри, то можно просто указывать тип внутренней коллекции в качестве возвращаемого типа для метода GetEnumerator()</li>
	<li>Если есть возможность без вреда для внешнего кода иметь в качестве параметра конкретную коллекцию, а не интерфейс, то это сможет улучшить производительность foreach</li>
	<li>Если такой возможности нет, можно например использовать IList и for вместо foreach</li>
</ul>
<h4>3. И еще немного о boxing: Перечисления в generic методах</h4>
В прошлой статье я много плохого написал о перечислениях. Но если у вас их достаточно много, то в generic методах есть возможность получать значения перечисления без боксинга. <a href="http://social.msdn.microsoft.com/Forums/vstudio/en-US/d8ae015c-ccce-4e34-b848-a9c804a9465a/converting-between-generic-enum-and-intlong-without-boxing?forum=clr">Здесь</a>, например, описан способ генерации метода, который позволяет получать числовые значения перечисления без боксинга. У нас в лавке мы дописали этот метод и теперь конвертируем спокойно value типы и generic параметры между собой. Есть еще один нюанс: данный подход не работает на моно. Но небольшими изменениям можно дописать необходимую функциональность. Возможно данные изменения попадут в скором времени в основную ветку моно.

<h4>4. И ещё чуть-чуть о выделении памяти: постоянное создание делегатов</h4>
В заключении небольшая мелочь о которой многие забывают. Предположим есть два метода:
<source lang="cs">
private static void Foo()
{
	Console.WriteLine("Foo");
}

private static void Execute(Action action)
{
	action();
}
</source>
Если сделать вызов <code>Execute(Foo)</code>, то мы получим следующий IL код:
<source lang="cs">
IL_009c:  ldftn      void HabraTests.Program::Foo()
IL_00a2:  newobj     instance void [mscorlib]System.Action::.ctor(object, native int)
IL_00a7:  call       void HabraTests.Program::Execute(class [mscorlib]System.Action)
</source>
То есть при каждом вызове создается объект. Когда вы пишете <code>eventName += methodName;</code> или в вызов метод, который принимает делегат, пишете просто название метода, то вы создаете объект. Когда это происходит редко, то ничего страшного, но если такой код выполняется часто, то вы плодите большое количество объектов. Поэтому, если у вас есть такие участки кода, то лучше сохранять делегат и передавать сохраненный объект, например так:
<source lang="cs">
private static Action _fooAction;

public static void Main()
{
	_fooAction = Foo;

	Execute(_fooAction);
}
</source>
<source lang="cs">
IL_0011:  ldsfld     class [mscorlib]System.Action HabraTests.Program::_fooAction
IL_0016:  call       void HabraTests.Program::Execute(class [mscorlib]System.Action)
</source>
Вот и всё. Напоследок хотелось бы сказать пару слов о процессе оптимизации. Большинство проблем кроется в алгоритмах структурах данных. По этой причине я предпочитаю сначала решать проблемы производительности и фиксить баги аналитическим путем. Таким образом вы решаете фундаментальные проблемы, а не делаете кучу подпорок в коде. Если это не помогает, то можно браться за профайлер и дебаггер. Также, если вы что-то решили прооптимизировать, то не стоит сразу пытаться выжать из нового кода всё и оптимизировать в нём самом каждую мелочь. Лучше быстро набросать грубую модель и посмотреть, есть ли выигрыш по сравнению с предыдущим подходом, а потом уже думать, что делать дальше.